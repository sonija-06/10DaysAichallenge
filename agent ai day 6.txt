# ======================================================
# üíº DAY 6: AI FRAUD DETECTION AGENT (UPDATED)
# üõ°Ô∏è "Naya Pay Security Desk" - Card Flag Agent
# üöÄ Primary Goal: Check User's Card Ending against Fraud Case Database
# ======================================================

import logging
import json
import os
from typing import Annotated, Optional
from pydantic import Field


print("üí° agent.py LOADED SUCCESSFULLY!")



# --- LiveKit Imports ---
from dotenv import load_dotenv
from livekit.agents import (
    Agent,
    AgentSession,
    JobContext,
    JobProcess,
    RoomInputOptions,
    WorkerOptions,
    cli,
    function_tool,
    RunContext,
)
from livekit.plugins import murf, silero, google, deepgram, noise_cancellation
from livekit.plugins.turn_detector.multilingual import MultilingualModel

logger = logging.getLogger("agent")
load_dotenv(".env.local")

# ======================================================
# üìÇ 1. FRAUD DATABASE SETUP
# ======================================================

FRAUD_DB_FILE = "fraud_db.json"

def load_fraud_database():
    """
    Loads the list of known fraudulent cases from the JSON file and maps them
    by 'cardEnding' for quick lookup.
    """
    db_path = os.path.join(os.path.dirname(__file__), FRAUD_DB_FILE)
    try:
        if not os.path.exists(db_path):
            print(f"‚ö†Ô∏è FRAUD DB not found at {db_path}. Using empty list.")
            return {}
        
        with open(db_path, "r", encoding='utf-8') as f:
            data = json.load(f)
            
            # Extract the list of cases under the "Naya Pay" key
            cases = data.get("Naya Pay", []) 
            
            # Map the cases by the cardEnding (last 4 digits) for fast lookup
            return {case["cardEnding"]: case for case in cases if "cardEnding" in case}
            
    except Exception as e:
        print(f"‚ö†Ô∏è Error loading Fraud DB: {e}")
        return {}

FRAUD_DATABASE = load_fraud_database()
print(f"Loaded {len(FRAUD_DATABASE)} unique card endings with case data.")

# ======================================================
# üõ†Ô∏è 2. CARD FLAG CHECK TOOL
# ======================================================

@function_tool
async def check_for_fraud_flag(
    ctx: RunContext,
    card_ending: Annotated[str, Field(description="The last four digits of the user's card to check for recent fraud flags.")]
) -> str:
    """
    Checks the user's card ending against a database of recent or confirmed fraud cases.
    Call this immediately after receiving the card ending from the user.
    """
    print(f"üîé CHECKING CARD ENDING: {card_ending}")
    
    # 1. Lookup in the pre-loaded dictionary
    fraud_record = FRAUD_DATABASE.get(card_ending)
    
    if fraud_record:
        status = fraud_record.get("case_status", "FLAGGED")
        userName = fraud_record.get("userName", "the account owner")
        
        if status == "confirmed_fraud":
            print(f"üö® CONFIRMED FRAUD DETECTED for {card_ending}.")
            # Return a clear, actionable instruction for the LLM
            return (f"üö® CONFIRMED FRAUD: User {userName} is associated with a confirmed fraud case. "
                    "Instruct the user that their card has been temporarily blocked and they must contact the security department (0800-NAYA-PAY) immediately.")
        
        elif status == "pending_review":
             print(f"‚ö†Ô∏è PENDING REVIEW DETECTED for {card_ending}.")
             return (f"‚ö†Ô∏è PENDING REVIEW: A suspicious transaction is pending review for user {userName}. "
                    "Inform the user that we need to verify a recent transaction before proceeding with any new transfers. Ask them to verify the last transaction details.")
    
    # Default: Safe or no relevant flag
    print(f"‚úÖ ACCOUNT SAFE: {card_ending}")
    return "‚úÖ ACCOUNT SAFE: This card ending has no outstanding fraud flags. Tell the user they can proceed with their request."

# ======================================================
# üß† 3. AGENT DEFINITION
# ======================================================

class SecurityAgent(Agent):
    def __init__(self):
        super().__init__(
            instructions=f"""
            You are 'Agent Zoya', a firm, professional Security Agent for Naya Pay.
            
            üéØ **YOUR PRIMARY GOAL:**
            1. Intercept the user's request for a transaction or account change.
            2. Verify the user's identity by asking for the **last four digits of their Naya Pay card**.
            3. **Immediately** call `check_for_fraud_flag` as soon as you receive the 4-digit card ending.
            
            ‚öôÔ∏è **BEHAVIOR:**
            - **Tool Use is Mandatory:** You **MUST** call the tool once the 4-digit card ending is provided.
            - **If CONFIRMED FRAUD:** Stop the conversation immediately, state clearly the card is blocked for security reasons, and instruct the user to call the security hotline (0800-NAYA-PAY). Do not continue.
            - **If PENDING REVIEW:** Ask the user to verify the last transaction shown in the case notes (e.g., "Was your last transaction $2,100.00 to an Unknown Crypto Exchange?"). Only proceed if they verify it as *theirs*. If they deny it, treat it as fraud.
            - **If SAFE:** Proceed politely and ask the user about their specific request (e.g., "How may I help you with your transaction?").
            
            üö´ **RESTRICTIONS:**
            - Your top priority is security. Never proceed if the card is flagged.
            - The security hotline is 0800-NAYA-PAY.
            """,
            tools=[check_for_fraud_flag],
        )

# ======================================================
# üé¨ 4. ENTRYPOINT
# ======================================================

def prewarm(proc: JobProcess):
    proc.userdata["vad"] = silero.VAD.load()

async def entrypoint(ctx: JobContext):
    ctx.log_context_fields = {"room": ctx.room.name}

  
    print("üöÄ STARTING NAYA PAY SECURITY SESSION")
    
    # 1. Setup Agent
    session = AgentSession(
        stt=deepgram.STT(model="nova-3"),
        llm=google.LLM(model="gemini-2.5-flash"),
        tts=murf.TTS(
            voice="en-US-ken", # A clear, firm voice for security
            style="Authoritative",
            text_pacing=True,
        ),
        turn_detection=MultilingualModel(),
        vad=ctx.proc.userdata["vad"],
        userdata={},
    )
    
    # 2. Start
    await session.start(
        agent=SecurityAgent(),
        room=ctx.room,
        room_input_options=RoomInputOptions(
            noise_cancellation=noise_cancellation.BVC()
        ),
    )

    await ctx.connect()

if __name__ == "__main__":
    # Ensure to replace this with your actual environment variables if running locally
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))