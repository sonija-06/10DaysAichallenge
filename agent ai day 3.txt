<<<<<<< HEAD
# Imports needed for Day 4
import os
import json
import random
from typing import Annotated, Literal
from pydantic import Field

# ... (Existing LiveKit, Murf, Google Imports)

# -------------------------------------------------------------
# CONTENT LOADING
# -------------------------------------------------------------
def load_content():
    # Adjust the path to correctly locate the JSON file
    base_dir = os.path.dirname(__file__)
    backend_dir = os.path.abspath(os.path.join(base_dir, ".."))
    content_path = os.path.join(backend_dir, "shared-data", "day4_tutor_content.json")
    
    if not os.path.exists(content_path):
        logger.error(f"Content file not found at: {content_path}")
        return []
        
    with open(content_path, 'r', encoding='utf-8') as f:
        return json.load(f)

COURSE_CONTENT = load_content()
CONCEPT_IDS = [c['id'] for c in COURSE_CONTENT]
ConceptID = Literal[tuple(CONCEPT_IDS)]

# -------------------------------------------------------------
# MODE AGENTS (The Tutors)
# -------------------------------------------------------------

class LearnAgent(Agent):
    """The agent that explains a concept."""
    def __init__(self, concept: str):
        super().__init__(
            instructions=f"""You are 'Matthew', a patient and technical instructor. Your task is to clearly and concisely teach the user about the concept of '{concept['title']}'. Your current mode is 'Learn'.
            
            1. Start by welcoming the user and presenting the summary of the concept.
            2. After presenting the summary, ask the user if they have any questions.
            3. Always remain in the Learn mode until the user explicitly asks to switch modes or concepts.
            4. The core explanation is: '{concept['summary']}'""",
            # Matthew's Voice
            tts_options=murf.TTS(voice="en-US-matthew", style="Narrative", text_pacing=True)
        )
        self.concept = concept

class QuizAgent(Agent):
    """The agent that quizzes the user on the concept."""
    def __init__(self, concept: str):
        super().__init__(
            instructions=f"""You are 'Alicia', a strict but encouraging quizmaster. Your current mode is 'Quiz'. Your task is to quiz the user on the concept of '{concept['title']}'.
            
            1. Start by asking the user the quiz question: '{concept['sample_question']}'.
            2. Listen for the user's answer. Give brief feedback (e.g., "That's a strong answer!") and then ask the user if they want to try another question or switch modes.
            3. Always remain in the Quiz mode until the user explicitly asks to switch modes or concepts.""",
            # Alicia's Voice
            tts_options=murf.TTS(voice="en-US-alicia", style="Conversational", text_pacing=True)
        )
        self.concept = concept

class TeachBackAgent(Agent):
    """The agent that asks the user to explain the concept back."""
    def __init__(self, concept: str):
        super().__init__(
            instructions=f"""You are 'Ken', an active listener and evaluator. Your current mode is 'Teach Back'. Your task is to have the user explain the concept of '{concept['title']}' back to you.
            
            1. Start by prompting the user with the instruction: '{concept['prompt_to_teach']}'.
            2. Listen to the user's explanation.
            3. Provide basic qualitative feedback (e.g., "That was a very clear explanation of the core idea," or "You missed the part about the condition.")
            4. Always remain in the Teach Back mode until the user explicitly asks to switch modes or concepts.""",
            # Ken's Voice
            tts_options=murf.TTS(voice="en-US-ken", style="Presentation", text_pacing=True)
        )
        self.concept = concept

# -------------------------------------------------------------
# CONTROL AGENT (The Handoff Manager)
# -------------------------------------------------------------

class ControlAgent(Agent):
    """The main agent that directs traffic and handles handoffs."""
    def __init__(self):
        super().__init__(
            instructions="""You are the main coordinator, responsible for greeting the user, selecting the starting concept (Variables) and mode, and managing the handoff.
            
            1. Greet the user and ask them to choose a mode: 'learn', 'quiz', or 'teach back'.
            2. Use the 'set_mode' tool to initiate the handoff once a mode is chosen.
            3. If the user asks to switch modes at any point, use the 'set_mode' tool again.
            4. The default concept to start with is 'variables'.""",
            # Control Agent uses a neutral voice
            tts_options=murf.TTS(voice="en-US-natalie", style="Conversational", text_pacing=True)
        )
        self.current_concept_id = "variables"
        self.concept_data = next(c for c in COURSE_CONTENT if c['id'] == self.current_concept_id)


    @function_tool
    async def set_mode(
        self,
        context: RunContext,
        new_mode: Annotated[
            Literal["learn", "quiz", "teach_back"],
            Field(description="The learning mode to switch to."),
        ],
        concept_id: Annotated[
            Optional[ConceptID],
            Field(description="Optional concept to switch to. Defaults to 'variables' if not provided."),
        ] = None,
    ) -> str:
        """Use this tool to switch the user to a new learning mode and/or concept."""
        
        # 1. Update Concept Data if provided
        if concept_id:
            self.current_concept_id = concept_id
            self.concept_data = next(c for c in COURSE_CONTENT if c['id'] == concept_id)
        
        # 2. Select the correct Agent class
        agent_map = {
            "learn": LearnAgent,
            "quiz": QuizAgent,
            "teach_back": TeachBackAgent,
        }
        
        new_agent_class = agent_map.get(new_mode)

        if not new_agent_class:
            return "I don't recognize that mode. Please choose 'learn', 'quiz', or 'teach back'."

        # 3. Perform the Handoff (The core of Day 4!)
        new_agent = new_agent_class(concept=self.concept_data)
        
        # The handoff will preserve context like the STT/LLM/TTS setup
        await context.handoff(agent=new_agent)

        return f"Switching you to the {new_mode.replace('_', ' ')} module for '{self.concept_data['title']}' now. Please listen for the new tutor's voice!"

# -------------------------------------------------------------
# ENTRYPOINT & INITIALIZATION (Modify the original entrypoint)
# -------------------------------------------------------------

# ... (Keep your prewarm function)

async def entrypoint(ctx: JobContext):
    ctx.log_context_fields = {"room": ctx.room.name}
    
    # 1. Setup Agent Pipeline
    session = AgentSession(
        stt=deepgram.STT(model="nova-3"),
        llm=google.LLM(model="gemini-2.5-flash"),
        
        # TTS is handled by the specific agents, but the session needs a default
        tts=murf.TTS(
            voice="en-US-natalie", 
            style="Conversational",
            text_pacing=True
        ),
        
        turn_detection=MultilingualModel(),
        vad=ctx.proc.userdata["vad"],
    )

    # 2. Start Session with the ControlAgent
    control_agent = ControlAgent()
    await session.start(
        agent=control_agent,
        room=ctx.room,
        room_input_options=RoomInputOptions(
            noise_cancellation=noise_cancellation.BVC(),
        ),
    )

    # 3. Start the conversation with the Control Agent's greeting
    await session.respond(
        f"Hello! Welcome to the Teach-the-Tutor learning system. We're starting with the concept of '{control_agent.concept_data['title']}'. Which mode would you like to start with: 'learn', 'quiz', or 'teach back'?"
    )

    await ctx.connect()


if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))
=======


import logging
import json
import os
import asyncio
from typing import Annotated, Literal, Optional
from dataclasses import dataclass

print("ðŸš€ BIOLOGY TUTOR - DAY 4 TUTORIAL")


from dotenv import load_dotenv
from pydantic import Field
from livekit.agents import (
    Agent,
    AgentSession,
    JobContext,
    JobProcess,
    RoomInputOptions,
    WorkerOptions,
    cli,
    function_tool,
    RunContext,
)

# ðŸ”Œ PLUGINS
from livekit.plugins import murf, silero, google, deepgram, noise_cancellation
from livekit.plugins.turn_detector.multilingual import MultilingualModel

logger = logging.getLogger("agent")
load_dotenv(".env.local")

# ======================================================
# ðŸ“š KNOWLEDGE BASE (BIOLOGY DATA)
# ======================================================

# ðŸ†• Renamed file so it generates fresh data for you
CONTENT_FILE = "biology_content.json" 

# ðŸ§¬ NEW BIOLOGY QUESTIONS
DEFAULT_CONTENT = [
  {
    "id": "dna",
    "title": "DNA",
    "summary": "DNA (Deoxyribonucleic acid) is the molecule that carries genetic instructions for the development and functioning of all known living organisms. It is shaped like a double helix.",
    "sample_question": "What is the full form of DNA and what is its structure called?"
  },
  {
    "id": "cell",
    "title": "The Cell",
    "summary": "The cell is the basic structural, functional, and biological unit of all known organisms. It is often called the 'building block of life'. Organisms can be single-celled or multicellular.",
    "sample_question": "What is the main difference between a Prokaryotic cell and a Eukaryotic cell?"
  },
  {
    "id": "nucleus",
    "title": "Nucleus",
    "summary": "The nucleus is a membrane-bound organelle found in eukaryotic cells. It contains the cell's chromosomes (DNA) and controls the cell's growth and reproduction.",
    "sample_question": "Why is the nucleus often referred to as the 'brain' or 'control center' of the cell?"
  },
  {
    "id": "cell_cycle",
    "title": "Cell Cycle",
    "summary": "The cell cycle is a series of events that takes place in a cell as it grows and divides. It consists of Interphase (growth) and the Mitotic phase (division).",
    "sample_question": "In which phase of the cell cycle does the cell spend the most time?"
  }
]

def load_content():
    """
    ðŸ“– Checks if biology JSON exists. 
    If NO: Generates it from DEFAULT_CONTENT.
    If YES: Loads it.
    """
    try:
        path = os.path.join(os.path.dirname(__file__), CONTENT_FILE)
        
        # Check if file exists
        if not os.path.exists(path):
            print(f"âš ï¸ {CONTENT_FILE} not found. Generating biology data...")
            with open(path, "w", encoding='utf-8') as f:
                json.dump(DEFAULT_CONTENT, f, indent=4)
            print("âœ… Biology content file created successfully.")
            
        # Read the file
        with open(path, "r", encoding='utf-8') as f:
            data = json.load(f)
            return data
            
    except Exception as e:
        print(f"âš ï¸ Error managing content file: {e}")
        return []

# Load data immediately on startup
COURSE_CONTENT = load_content()

# ======================================================
# ðŸ§  STATE MANAGEMENT
# ======================================================

@dataclass
class TutorState:
    """ðŸ§  Tracks the current learning context"""
    current_topic_id: str | None = None
    current_topic_data: dict | None = None
    mode: Literal["learn", "quiz", "teach_back"] = "learn"
    
    def set_topic(self, topic_id: str):
        # Find topic in loaded content
        topic = next((item for item in COURSE_CONTENT if item["id"] == topic_id), None)
        if topic:
            self.current_topic_id = topic_id
            self.current_topic_data = topic
            return True
        return False

@dataclass
class Userdata:
    tutor_state: TutorState
    agent_session: Optional[AgentSession] = None 

# ======================================================
# ðŸ› ï¸ TUTOR TOOLS
# ======================================================

@function_tool
async def select_topic(
    ctx: RunContext[Userdata], 
    topic_id: Annotated[str, Field(description="The ID of the topic to study (e.g., 'dna', 'cell', 'nucleus')")]
) -> str:
    """ðŸ“š Selects a topic to study from the available list."""
    state = ctx.userdata.tutor_state
    success = state.set_topic(topic_id.lower())
    
    if success:
        return f"Topic set to {state.current_topic_data['title']}. Ask the user if they want to 'Learn', be 'Quizzed', or 'Teach it back'."
    else:
        available = ", ".join([t["id"] for t in COURSE_CONTENT])
        return f"Topic not found. Available topics are: {available}"

@function_tool
async def set_learning_mode(
    ctx: RunContext[Userdata], 
    mode: Annotated[str, Field(description="The mode to switch to: 'learn', 'quiz', or 'teach_back'")]
) -> str:
    """ðŸ”„ Switches the interaction mode and updates the agent's voice/persona."""
    
    # 1. Update State
    state = ctx.userdata.tutor_state
    state.mode = mode.lower()
    
    # 2. Switch Voice based on Mode
    agent_session = ctx.userdata.agent_session 
    
    if agent_session:
        if state.mode == "learn":
            # ðŸ‘¨â€ðŸ« MATTHEW: The Lecturer
            agent_session.tts.update_options(voice="en-US-matthew", style="Promo")
            instruction = f"Mode: LEARN. Explain: {state.current_topic_data['summary']}"
            
        elif state.mode == "quiz":
            # ðŸ‘©â€ðŸ« ALICIA: The Examiner
            agent_session.tts.update_options(voice="en-US-alicia", style="Conversational")
            instruction = f"Mode: QUIZ. Ask this question: {state.current_topic_data['sample_question']}"
            
        elif state.mode == "teach_back":
            # ðŸ‘¨â€ðŸŽ“ KEN: The Student/Coach
            agent_session.tts.update_options(voice="en-US-ken", style="Promo")
            instruction = "Mode: TEACH_BACK. Ask the user to explain the concept to you as if YOU are the beginner."
        else:
            return "Invalid mode."
    else:
        instruction = "Voice switch failed (Session not found)."

    print(f"ðŸ”„ SWITCHING MODE -> {state.mode.upper()}")
    return f"Switched to {state.mode} mode. {instruction}"

@function_tool
async def evaluate_teaching(
    ctx: RunContext[Userdata],
    user_explanation: Annotated[str, Field(description="The explanation given by the user during teach-back")]
) -> str:
    """ðŸ“ call this when the user has finished explaining a concept in 'teach_back' mode."""
    print(f"ðŸ“ EVALUATING EXPLANATION: {user_explanation}")
    return "Analyze the user's explanation. Give them a score out of 10 on accuracy and clarity, and correct any mistakes."

# ======================================================
# ðŸ§  AGENT DEFINITION
# ======================================================

class TutorAgent(Agent):
    def __init__(self):
        # Generate list of topics for the prompt
        topic_list = ", ".join([f"{t['id']} ({t['title']})" for t in COURSE_CONTENT])
        
        super().__init__(
            instructions=f"""
            You are an Biology Tutor designed to help users master concepts like DNA and Cells.
            
            ðŸ“š **AVAILABLE TOPICS:** {topic_list}
            
            ðŸ”„ **YOU HAVE 3 MODES:**
            1. **LEARN Mode (Voice: Matthew):** You explain the concept clearly using the summary data.
            2. **QUIZ Mode (Voice: Alicia):** You ask the user a specific question to test knowledge.
            3. **TEACH_BACK Mode (Voice: Ken):** YOU pretend to be a student. Ask the user to explain the concept to you.
            
            âš™ï¸ **BEHAVIOR:**
            - Start by asking what topic they want to study.
            - Use the `set_learning_mode` tool immediately when the user asks to learn, take a quiz, or teach.
            - In 'teach_back' mode, listen to their explanation and then use `evaluate_teaching` to give feedback.
            """,
            tools=[select_topic, set_learning_mode, evaluate_teaching],
        )

# ======================================================
# ðŸŽ¬ ENTRYPOINT
# ======================================================

def prewarm(proc: JobProcess):
    proc.userdata["vad"] = silero.VAD.load()

async def entrypoint(ctx: JobContext):
    ctx.log_context_fields = {"room": ctx.room.name}



    
    # 1. Initialize State
    userdata = Userdata(tutor_state=TutorState())

    # 2. Setup Agent
    session = AgentSession(
        stt=deepgram.STT(model="nova-3"),
        llm=google.LLM(model="gemini-2.5-flash"),
        tts=murf.TTS(
            voice="en-US-matthew", 
            style="Promo",        
            text_pacing=True,
        ),
        turn_detection=MultilingualModel(),
        vad=ctx.proc.userdata["vad"],
        userdata=userdata,
    )
    
    # 3. Store session in userdata for tools to access
    userdata.agent_session = session
    
    # 4. Start
    await session.start(
        agent=TutorAgent(),
        room=ctx.room,
        room_input_options=RoomInputOptions(
            noise_cancellation=noise_cancellation.BVC()
        ),
    )

    await ctx.connect()

if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))
>>>>>>> ca4fec5576c179e2f0226f2220efbb6658ce15df
